# Intelragdemo (DT-IFG) Production System Review

## 1. Context & Objectives
- **Mission**: The DT-IFG platform delivers “Intel for Good” research and case management capabilities built on Retrieval-Augmented Generation (RAG).
- **Current hosting**: Primary GCP project `intelragdemo` (project #764105815249) coupled with a sizeable Azure footprint for data ingestion and retrieval APIs.
- **Goal of this review**: Capture how the production stack works today to inform migration/modernisation plans for the next-generation i4g platform.
- **Inputs analysed**: GCP resource inventory (5 Nov 2025 export), three source repositories (`IFG-ChatUI`, `IFG-AzureFunctions`, `IFG-GCPFunctions`), and the accompanying RAG documentation set.

## 2. High-Level Architecture
- **Frontend**: Next.js application (`IFG-ChatUI`) deployed through Firebase Hosting + Firebase Functions (SSR code runs as Cloud Function `ssrintelragdemo` in `us-east1`).
- **Application APIs (GCP)**: Firebase/Cloud Functions (Gen 2) exposed as callable HTTPS endpoints. Key handlers:
  - `getAIChatResponse` and `getSignedUrl` (Node.js 18, `us-central1`)
  - `updateLastLogin` (Firebase Identity trigger)
  - Python-based processors `process-data` and `process-account-extract` (Gen2 Cloud Functions fronting Cloud Run services in `us-central1`).
- **Azure services**: Azure Functions handle data ingestion, enrichment, and Azure Cognitive Search operations. Azure Blob Storage stores raw artefacts; an Azure SQL DB is referenced by ingestion jobs.
- **Data plane**: Firestore `(default)` in `us-east4` for application state and user metadata; Azure Blob Storage for document payloads; custom search indices in Azure Search.
- **Identity**: Firebase Authentication (before-sign-in trigger updates user metadata). Secret Manager stores shared secrets (Azure storage keys, API keys for Azure-hosted chatbot service).
- **Integrations**: Callable Cloud Functions invoke Azure HTTP APIs (e.g., `chatbot-querying.azurewebsites.net/api/chat`) and generate short-lived Azure Blob SAS URLs for document retrieval.

### Primary Flows
1. **User session**: User signs into the Firebase-backed UI; `updateLastLogin` records activity in Firestore.
2. **Chat interaction**: UI calls the callable `getAIChatResponse`. Function fetches API key from Secret Manager, forwards query to the Azure chatbot endpoint, returns RAG response + citations.
3. **Document access**: UI requests `getSignedUrl`, which retrieves Azure storage credentials from Secret Manager and issues a 15-minute SAS URL for the requested blob.
4. **Data refresh**: Azure Functions (`process_intake_forms`, `process_groupsio`, account list workflows, etc.) ingest external sources, normalise them, and publish into Azure SQL / Azure Blob containers consumed by the chat and search experiences.
5. **Search services**: Azure-hosted APIs (multi-index / hybrid / vector search) surface content to both the chat function and other sharing gateways. GCP `process-data` functions appear to bridge Azure ingestion with Google tooling (exact behaviour to confirm).

## 3. Application Components

### 3.1 Frontend (IFG-ChatUI)
- **Framework**: Next.js 14 + TypeScript; Tailwind for styling.
- **Deployment**: Firebase Hosting (frameworks integration targeting `us-east1`). SSR logic runs in the Cloud Function `ssrintelragdemo` (Node.js 20).
- **Client features**:
  - Uses Firebase Authentication; Firestore security rules require authenticated users for all reads/writes.
  - Interacts with callable functions (`getAIChatResponse`, `getSignedUrl`) for core features.
  - `adminFirebase.js` suggests optional admin tooling for Firestore.
- **Firestore**: No custom indexes defined; relies on basic queries.

### 3.2 GCP Cloud Functions (from IFG-ChatUI `functions/` and IFG-GCPFunctions)

| Function | Runtime | Region | Purpose | Notes |
|---|---|---|---|---|
| `getAIChatResponse` | Node.js 18 | `us-central1` | Callable HTTPS; relays chat prompt to Azure chatbot API using Secret Manager-stored API key | Allows CORS for production + localhost; requires Firebase auth |
| `getSignedUrl` | Node.js 18 | `us-central1` | Callable HTTPS; generates read-only Azure Blob SAS URL | Tight coupling to Azure storage account secrets |
| `updateLastLogin` | Node.js 18 | `us-central1` | Firebase `beforeUserSignedIn` trigger; updates `users/{uid}` `lastLogin` field | Uses Firestore server timestamp |
| `process-account-extract` | Python 3.11 | `us-central1` | HTTP entry fronting a Cloud Run service; likely invoked by Azure/GCP schedulers for data sync | `timeout=600s`, concurrency 1, service account is default compute |
| `process-data` | Python 3.11 | `us-central1` | Similar to above; part of ingestion bridge | `timeout=600s` |
| `ssrintelragdemo` | Node.js 20 | `us-east1` | Next.js SSR entry generated by Firebase Hosting frameworks integration | Serves the UI |

> **Observation**: The discovery export did not surface any Cloud Scheduler jobs or Pub/Sub topics; if scheduled invocations exist, they likely run on Azure (see Azure Functions “client” projects) or use Firebase scheduled functions triggered elsewhere.

### 3.3 Azure Functions (IFG-AzureFunctions)
- **Process intake & enrichment**: `process_intake_forms`, `process_groupsio`, `account_list_extract`, etc. fetch data from Google Forms, Groups.IO, and other sources, storing results in Azure SQL / Blob storage. These Python functions appear to run on schedules (described in repo as weekly/twice-monthly jobs).
- **Chatbot Query & Search**: `chatbot_query`, `multi_index_search` orchestrate retrieval pipelines across Azure Cognitive Search indices with LLM prompting.
- **Utilities**: Scripts to manage Azure Search indexes and test ingestion flows.
- **Client triggers**: `account_list_extract_client` schedules downstream processes and pushes results to Google Drive (bridge between Azure and Google services).

### 3.4 Google Cloud Functions Repository (IFG-GCPFunctions)
- Mirrors Azure capabilities for the Google Cloud environment:
  - `accounts_list`, `account_list_client`: GCP-native versions of the banking account detection pipeline.
  - `chatbot_query`, `hybrid_search`, `vector_search`, `fetch_data_objects`: Provide HTTP APIs (likely behind API Gateway, per documentation folder) for querying and retrieving documents.
- These projects suggest a mix of Node.js and Python code (full inspection pending). Deployment state in production is limited—only the Firebase functions and two Python processors are currently active in `intelragdemo`.

### 3.5 Documentation Set
- Four `.docx` files covering Azure/GCP API specs and technical documentation, plus a billing management guide. These likely contain sequence diagrams, API contracts, and operational procedures that complement this review. (Not parsed here but recommended for the migration backlog.)

## 4. Data & Storage
- **Firestore**: Single default database, `us-east4`, native mode, free tier, PITR disabled. Pessimistic concurrency and realtime updates enabled. Used for user profiles/auth metadata (per `updateLastLogin`).
- **Azure Blob Storage**: Primary content store; callable function generates SAS URLs. Container naming inferred from blob URLs supplied by the UI.
- **Azure SQL**: Target for ingestion functions handling intake forms, GroupsIO, etc. (per Azure repo docs).
- **Search**: Azure Cognitive Search indices power multi-index and hybrid search APIs. No evidence of managed search in GCP.
- **Cloud SQL**: No instances detected in GCP inventory (empty list).
- **Pub/Sub & Eventing**: No topics/subscriptions currently deployed in production; cross-system communication relies on direct HTTP calls and shared storage.

## 5. Integrations & External Dependencies
- **Azure**: Storage, Functions, Cognitive Search, possibly Azure OpenAI. Shared secrets stored in GCP Secret Manager (`api-chatbot-query`, Azure storage credentials).
- **Google Services**: Firebase Auth, Hosting, Firestore, Cloud Functions, Cloud Run, Artifact Registry. No BigQuery or Vertex AI usage observed in inventory.
- **Third-Party**: GroupsIO API, Google Forms (for intake), Google Drive (for scheduled delivery from Azure functions).
- **CI/CD**: Firebase CLI (per labels) and Cloud Build service account with wide privileges. Repositories likely deploy via manual scripts or Firebase deploy commands.

## 6. Operations & Scheduling
- **Scheduling**: Azure “client” functions handle recurring jobs (e.g., twice-monthly account extraction). Cloud Scheduler is enabled, but no jobs are provisioned in GCP (asset lookup unsupported; manual verification recommended).
- **Logging & Monitoring**: No Cloud Logging exports captured in the bundle. Functions rely on default logging. Artifact Registry + Cloud Build in use for deployments.
- **Secrets**: Managed via Secret Manager; functions fetch secrets on demand. Ensure rotation processes exist (not documented here).
- **Environments**: Single production project. No dev/staging projects captured in this review.

## 7. IAM & Security Posture
- **Service accounts**:
  - Default Compute Engine SA (`764105815249-compute@...`) acts as editor—high privileges; also used by all Gen2 functions.
  - Firebase admin, Firebase app hosting, discovery reader, and two Azure bridge service accounts present.
- **Roles**:
  - Numerous service-agent bindings for Firebase, Cloud Functions, Cloud Scheduler, Artifact Registry, etc.
  - Custom `discovery-reader` SA granted viewer roles across Cloud Functions, Scheduler, Cloud SQL, Datastore.
  - Two Azure bridge service accounts have `roles/browser`; unclear if additional roles granted outside captured excerpt.
- **Firestore security**: Rules enforce authenticated access for all documents.
- **Networking**: All Cloud Functions allow ingress from the public internet (default), with authentication handled at the Firebase callable layer.
- **Risks**:
  - Default compute SA retaining `roles/editor` is over-privileged; principle of least privilege would suggest custom least-privilege SAs for each function.
  - No VPC/SSE configuration captured; assume public egress to Azure endpoints.

## 8. Regional Footprint & Resource Consumption
- **Regions**:
  - `us-central1`: Most callable functions (`getAIChatResponse`, `getSignedUrl`, `process-*`), Artifact Registry, Cloud Run services.
  - `us-east1`: SSR function; Firebase Hosting frameworks config; Firestore location `us-east4`.
  - Azure components likely hosted in East US (infer from storage endpoints). Consider latency implications between UI (east) and APIs (central) and cross-cloud hops.
- **Scaling**: Functions configured with generous max instance counts (100) but modest CPU/memory (256Mi). Python processors limited to concurrency 1.
- **Costs**: No billing data in inventory; given light footprint (no Cloud SQL/BigQuery), major spend is likely Firebase, Cloud Functions, Artifact Registry storage, plus Azure workloads.

## 9. Known Gaps & Open Questions
1. **Scheduler visibility**: Cloud Asset inventory cannot list scheduler jobs; manual confirmation needed to verify none exist.
2. **Firestore indexes**: Asset inventory cannot capture index metadata; Firestore indexes file is empty, but confirm if composite indexes exist in Firebase console.
3. **Azure-GCP auth pathway**: Clarify how Azure Functions authenticate when calling GCP APIs (service accounts `azure-data-processing` vs `azure-data-processing-272`). Identify whether keys or workload identity federation are used.
4. **Data lineage**: Need detailed mapping from ingestion (Forms/GroupsIO) → storage → search indices → chat responses.
5. **Error handling & monitoring**: No evidence of centralized logging/alerting; determine production incident response setup.
6. **CI/CD pipelines**: Cloud Build SA has broad roles; document deployment process and lock down permissions.
7. **Secrets rotation**: Ensure rotation cadence for Azure storage keys and chatbot API key stored in Secret Manager.
8. **Documentation alignment**: Review the `.docx` technical documentation to reconcile with this snapshot; flag any drift.

## 10. Recommendations / Next Steps
1. **Confirm inventory gaps**: Manually list Cloud Scheduler jobs, Firestore indexes, and any other scheduled triggers not covered by the export.
2. **IAM hardening**: Create dedicated service accounts per function with least-privilege roles; remove `roles/editor` from default compute SA.
3. **Topology diagram**: Produce a formal architecture diagram depicting cross-cloud flows (UI ↔ GCP ↔ Azure). RAG documentation likely has drafts—update if necessary.
4. **Operational runbooks**: Capture current deployment, monitoring, and incident workflows from the `.docx` docs in text form for version control.
5. **Data-flow deep dive**: For each Azure ingestion pipeline, enumerate sources, schedules, destinations, and dependencies to inform eventual migration sequencing.
6. **Performance/latency review**: Measure chat query latency across Firebase callable → Azure API chain; consider regional alignment or caching for the next-gen design.
7. **Plan for consolidation**: Use this review as baseline to compare against the desired i4g architecture (e.g., moving ingestion/search workloads natively into GCP or other preferred stack).

---
*Prepared 5 Nov 2025 based on latest discovery export and repository snapshot. Update this document as additional details surface or architectural decisions evolve.*
